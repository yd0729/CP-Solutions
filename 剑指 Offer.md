# 剑指 Offer

## 63. 股票的最大利润（DP）

## 58 - II. 左旋转字符串

substr

## 58 - I. 翻转单词顺序（字符串） ⭐️

可以原地颠倒：

1. 整体翻转
2. 对每个单词翻转

## 57. 和为s的两个数字（双指针）

## 53 - II. 0 ～ n-1 中缺失的数字（二分查找） ⭐️

题中少说了一种情况，如果没有缺失的数字，返回 n ．

## 53 - I. 在排序数组中查找数字 I

## 52. 两个链表的第一个公共节点（链表、双指针） ⭐️

## 50. 第一个只出现一次的字符（哈希、队列、延迟删除） ⭐️

### 使用哈希表存储频数

遍历 2 次字符串．

### 使用哈希表存储索引

遍历 1 次字符串 + 1 次哈希表．

### 使用哈希表存储索引 + 队列

遍历 1 次字符串，需要队列．

延迟删除：「在维护队列时，我们使用了「延迟删除」这一技巧。也就是说，即使队列中有一些字符出现了超过一次，但它只要不位于队首，那么就不会对答案造成影响，我们也就可以不用去删除它。只有当它前面的所有字符被移出队列，它成为队首时，我们才需要将它移除。」

## 48. 最长不含重复字符的子字符串（哈希） ⭐️

## 47. 礼物的最大价值（DP）

## 46. 把数字翻译成字符串（递归）

## 42. 连续子数组的最大和（DP）

## 35. 复杂链表的复制（回溯、哈希、迭代） ⭐️

### 回溯 + 哈希表

用一个哈希表记录已经拷贝的节点，然后递归地拷贝结点．

### 迭代 + 节点拆分

1. 把拷贝的节点放在原结点的后面
2. 拷贝 random
3. 把拷贝的链表和原链表拆分出来

## 32 - III. 从上到下打印二叉树 III（二叉树、层序遍历、双端队列）

得到一层的遍历后 reverse ，也可用双端队列存储．

## 32 - II. 从上到下打印二叉树 II（二叉树、层寻遍历） ⭐️

每次连续弹出 `q.size()` 个．

## 32 - I. 从上到下打印二叉树（二叉树、层序遍历）

二叉树的层序遍历．

## 30. 包含 min 函数的栈（辅助栈） ⭐️

额外用一个保存最小值的栈．

## 28. 对称的二叉树（二叉树）

## 27. 二叉树的镜像（二叉树）

## 26. 树的子结构（二叉树） ⭐️

从每个节点开始递归比较．

## 25. 合并两个排序的链表（链表） ⭐️

见 LeetCode 21 ．

## 24. 反转链表（链表、头插法） ⭐️

1. 需要一个辅助节点
2. 头插法

## 22. 链表中倒数第k个节点（链表、双指针） ⭐️

## 21. 调整数组顺序使奇数位于偶数前面（双指针） ⭐️

## 18. 删除链表的节点（链表） ⭐️

## 12. 矩阵中的路径（回溯、DFS） ⭐️

## 11. 旋转数组的最小数字（二分查找） ⭐️

## 10 - I. 斐波那契数列（DP）

## 10 - II. 青蛙跳台阶问题（DP）

## 09. 用两个栈实现队列（栈、队列） ⭐️

两个栈，有一个 in ，一个 out ．

in 用来实现队列的输入， out 用来实现队列的输出．

每次需要 pop 但是 out 空时，需要将 in 中的元素逐个取出并 push 到 out 中．

## 06. 从尾到头打印链表（链表）

## 05. 替换空格（字符串）

用 vector 作为 C++ 的 stringbuilder ．

## 04. 二维数组中的查找（线性查找） ⭐️

> 由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素。
>
> 从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。
>
> 可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。

从左下角开始也行．

## 03. 数组中重复的数字

在把数字交换到正确的位置的过程中找重复的数字．
