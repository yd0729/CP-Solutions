### 一、模板类别

​	数据结构：线段树套平衡树（ `zkw` 线段树套结点大小平衡树）。以下简称树套树。

### 二、模板功能

#### 1.建立树套树

1. 数据类型

   模板参数 `typename _Tp` ，表示平衡树的键类型。

   模板参数 `_typename _Fp` ，表示平衡树的值类型。在 `set` 和 `multiset` 里不需要这个参数，将其设置为 `bool` 类型。

   模板参数 `typename _Compare` ，表示排序函数的类，默认为 `_Tp` 的小于号比较类。

   模板参数 `_Tag`，表示树的类型:

   1. `_Tag=SizeBalancedZkwTreeSetTag` 表示内层树模拟 `std::set` ；
   2. `_Tag=SizeBalancedZkwTreeMultisetTag` 表示内层树模拟 `std::multiset` ；
   3. `_Tag=SizeBalancedZkwTreeMapTag` 表示内层树模拟 `std::map` ；

   构造参数 `int __n` ，表示树套树维护的区间范围为 `[0, __n)`。

   构造参数 `_Compare  __comp` ，表示具体的排序函数，默认为`_Compare` 类的默认实例。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本数据结构的功能为维护区间，可以将子区间转化为一棵或者多棵平衡树，从而进行基于树的各种操作。

   本数据结构与动态开点线段树套结点大小平衡树的功能、接口完全一致（除设置内存池函数不一致外）。

#### 2.建立树套树

1. 数据类型

   构造参数 `_Iterator __first`​ ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   $O(n\cdot \log n)$ 。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区域初状态直接赋到树套树里。


####  3.重置

1. 数据类型

   输入参数 `int __n` ，表示树套树维护的区间范围为 `[0, __n)`。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   调用本函数会将树套树的区间大小改变，并将之前的区间信息重置。

#### 4.重置

1. 数据类型

   构造参数 `_Iterator __first`​ ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   $O(n\cdot \log n)$ 。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区域初状态直接赋到树套树里。

#### 5.设置内存池大小

1. 数据类型

   输入参数 `int __count`，表示程序运行最多用到的结点数量。

2. 时间复杂度

   $O(n)$

3. 备注

   本方法和其他数据结构设置内存池的方法相同，只需要传一个参数。

   一般设为区间长度的对数倍即可。


#### 6.单点插入

1. 数据类型

   输入参数 `int __i` ，表示单点插入的下标。

   输入参数 `_Tp __key​` ，表示插入的键。

   输入参数 `_Fp __value` ，表示要插入的值。本参数仅在 `map` 里用到。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 7.单点更新

1. 数据类型

   输入参数 `int __i` ，表示单点更新的下标。

   输入参数 `_Tp __key`​ ，表示要更新的键。

   输入参数 `_Fp __value` ，表示要更新的值。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   本函数只适用于 `map` ；如果键不存在则会插入新的键值对。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 8.单点删除

1. 数据类型

   输入参数 `int __i` ，表示单点删除的下标。

   输入参数 `_Tp __key`​ ，表示要删除的键。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   本函数适用于所有类型；如果允许键重复则只删除一个而非全部。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 9.区间查询排名

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `_Tp __key`​ ，表示要获取排名的键。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   本函数的排名以 `0` 为基准；实际等同于树中小于该键值的元素数量。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 10.区间查询第 k 个元素

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `int __k`​ ，表示要查询的名次。

   输入参数 `_Tp __min`​ ，表示二分的下限。

   输入参数 `_Tp __max` ，表示二分的上限。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示区间内排名 `k` 的元素所在的位置。

2. 时间复杂度

   $O(\log^3 n)$ 。

3. 备注

   本函数基于二分进行查询，所以仅当 `_Tp` 类可以二分时有效。

   本函数的排名以 `0` 为基准。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 11.区间查询二分下界

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示区间内第一个大于等于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 12.区间查询二分上界

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示区间内第一个大于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 13.区间查询二分下界的前驱

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示区间内最后一个小于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 14.区间查询元素数量

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 15.区间查询是否为空

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 16.区间查询某元素数量

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   输入参数 `_Tp __key` ，表示要查询的键。

2. 时间复杂度

   $O(\log^2 n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 17.查询表示区间的树集

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

   返回类型 `std::vector<_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*>` ，即用于表示查询区间的树集。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数用于返回一个数组，这个数组里的树每棵树都可以表达一个子区间，这些子区间合起来就是要查询的区间。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 18.对树插入

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要进行操作的树。

   输入参数 `_Tp __key​` ，表示插入的键。

   输入参数 `_Fp __value` ，表示要插入的值。本参数仅在 `map` 里用到。

2. 时间复杂度

   $O(\log n)$ 。

#### 19.对树更新

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要进行操作的树。

   输入参数 `_Tp __key`​ ，表示要更新的键。

   输入参数 `_Fp __value` ，表示要更新的值。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数只适用于 `map` ；如果键不存在则会插入新的键值对。

#### 20.对树删除

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要进行操作的树。

   输入参数 `_Tp __key`​ ，表示要删除的键。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数适用于所有类型；如果允许键重复则只删除一个而非全部。

#### 21.查询树内排名

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key`​ ，表示要获取排名的键。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数的排名以 `0` 为基准；实际等同于树中小于该键值的元素数量。

#### 22.查找树内第 k 个元素

1. 数据类型：

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   参数 `int __k` ，表示要查询的顺次。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示元素所在的位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数的排名以 `0` 为基准。

#### 23.查询树内某元素

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示树内元素所在的位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 24.查询树内二分下界

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示树内第一个大于等于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 25.查询树内二分上界

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示树内第一个大于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 26.查询树内二分下界的前驱

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key`​ ，表示要查询的键。

   返回类型 `_SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>*` ，表示树内最后一个小于 `__key` 的元素所在的位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 27.查询树内元素数量

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

2. 时间复杂度

   $O(1)$ 。

#### 28.查询树是否为空

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

2. 时间复杂度

   $O(1)$ 。

#### 29.查询树内某元素数量

1. 数据类型

   输入参数 ` _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag>* __root` ，表示要查询的树。

   输入参数 `_Tp __key` ，表示要查询的键。

2. 时间复杂度

   $O(\log n)$ 。

### 三、模板示例

```c++
#include "DS/SizeBalancedZkwTree.h"
#include "IO/LeetcodeIO.h"

int main() {
    //树套树只展示 multiset 用法
    int A[10]={14,19,12,13,15,18,17,11,16,20};
    
    //直接将 A 数组整个区间赋给树套树
    OY::SizeBalancedZkwTreeContainer::Multiset<int>T(A,A+10);
    //查询每个长度为 1 的子区间的大小
    for(int i=0;i<10;i++)
        cout<<T.size(i,i)<<' ';
    cout<<endl;
    //查询每个长度为 1 的子区间内的第一个正元素
    for(int i=0;i<10;i++)
        cout<<T.upper_bound(i,i,0)->key<<' ';
    cout<<endl;
    //查询子区间内排名
    cout<<"17'rank in A[2~7]:  "<<T.rank(2,7,17)<<endl;
    //查询子区间内的 smaller_bound
    cout<<"17'smaller_bound in A[2~7]:  "<<T.smaller_bound(2,7,17)->key<<endl;
    //查询子区间内的 lower_bound
    cout<<"17'lower_bound in A[2~7]:  "<<T.lower_bound(2,7,17)->key<<endl;
    //查询子区间内的 upper_bound
    cout<<"17'upper_bound in A[2~7]:  "<<T.upper_bound(2,7,17)->key<<endl;
    //利用二分性质来手写 kth 函数
    //查询 A[2~7] 排名第 4 的元素
    {
        int low=-100000,high=100000;
        while(low<high){
            int mid=(low+high+1)/2;
            int rnk=T.rank(2,7,mid);
            if(rnk>4)high=mid-1;
            else low=mid;
        }
        cout<<"A[2~7] No.4 is: "<<low<<endl;
    }
    //当然，如果预知这个数的范围，可以不用搜那么大的范围，而是精准传参，调用 kth 方法
    //当然，这个有序区间必须足够精细，否则不可能搜到精准的点位
    {
        cout<<"A[2~7] No.4 is: "<<T.kth(2,7,4,1,100)->key<<endl;
    }
    //可能有人问，那如果要对 [0, 1000000000] 进行二分，也要准备一个长度十亿的数组吗？
    //这种情况下你可以使用第一种写法，手写二分。效率基本是一样的

    //还可以进行插入元素
    T.insert(5,100);
    T.insert(5,200);
    //这样，在下标 5 就聚集了三个元素
    cout<<"number of elems in pos 5: "<<T.size(5,5)<<endl;

    //*************************************************************************
    //此处，必须揭晓一下那些针对树进行操作的函数的作用。
    //比如，我们要搜区间 [2~7] 的元素数量
    cout<<"number of elems in pos[2~7]:"<<T.size(2,7)<<endl;
    //我们可以把动作拆分
    //首先找出表示这个区间的树集
    auto trees=T.find_roots(2,7);
    //然后分别打出它们的元素数量
    for(auto tree: trees)
        cout<<T.size(tree)<<' ';
    cout<<endl;
    //可以看到结果是一样的

    //比如我们要搜区间 [2~7] 内，元素 18 的排名
    int smaller=0;
    for(auto tree: trees)
        smaller+=T.rank(tree, 18);
    //这样拆分动作，和直接调用区间 rank 是一个效果
    if(smaller==T.rank(2,7,18))
        cout<<"same result\n";
}
```

```
#输出如下
1 1 1 1 1 1 1 1 1 1 
14 19 12 13 15 18 17 11 16 20 
17'rank in A[2~7]:  4
17'smaller_bound in A[2~7]:  15
17'lower_bound in A[2~7]:  17
17'upper_bound in A[2~7]:  18
A[2~7] No.4 is: 17
A[2~7] No.4 is: 17
number of elems in pos 5: 3
number of elems in pos[2~7]:8
1 1 4 1 1 
same result


```

