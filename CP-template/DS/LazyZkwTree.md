### 一、模板类别

​	数据结构：带懒惰标记的线段树

### 二、模板功能

#### 1.建立线段树

1. 数据类型

   模板参数 `typename _Tp` ，表示原有元素的类型。

   模板参数 `typename _Fp` ，表示增量元素的类型。

   模板参数 `typename _Operation` ，表示区间操作函数的类，默认为 `std::plus<_Tp>` ，也就是加法。

   模板参数 `typename _Mapping` ，表示增值函数的类，默认为 `OY::LazyZkwAdd<_Tp,_Fp>` ，也就是对某个 `_Tp` 对象增加若干数量的 `_Fp` 对象。

   模板参数 `typename _Composition` ，表示囤积函数的类，默认为 `std::plus<_Fp>` ，也就是加法。

   构造参数 `int n` ，表示线段树的覆盖范围为 `[0,n)`。

   构造参数 `_Operation __op` ，表示具体的区间操作函数。默认为 `_Operation` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Mapping __map` ，表示具体的增值函数。默认为 `_Mapping` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Composition __com` ，表示具体的囤积函数。默认为 `_Composition` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Tp __defaultValue` ，表示原有元素的默认值，默认为 `_Tp` 类的默认实例。

   构造参数 `_Fp __defaultIncrement` ，表示增值元素的默认值，默认为 `_Fp` 类的默认实例。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   带懒惰标记的线段树处理的问题为单点/区间修改，单点/区间的查询。

   带懒惰标记的线段树要求区间操作函数、增值函数和屯积函数的运算符都满足**结合律**。

   在理解带懒惰标记的线段树的各种参数之前，请先理解普通的线段树参数。

   `_Fp` 不一定是和 `_Tp` 不一样的类，完全可以是相同的类.

   `__op` 函数与线段树的区间操作函数作用相同，为 `_Tp __op(_Tp,_Tp)` 的形式。

   `__map` 函数可以传递二元函数，也可以传递三元函数。如果传递二元函数，为 `_Tp __map(_Fp,_Tp)` 的形式，表示前者为增量，后者为原值，返回原值被增量修改后的值；如果传递三元函数，为 `_Tp __map(_Fp,_Tp,int)` 的形式，第三个参数表示当前结点大小。（为什么要传递第三个参数？不妨考虑一个问题，如果一个结点维护一个长度为 `100` 的区间。此时，令该区间所有元素增加 `5` 的值，请问这段区间的和值增加多少？显然是 `5*100=500`，在这个情境下必须要知道结点大小，才能计算出增量带来的变化大小。）

   `__com` 函数为 `_Fp __com(_Fp,_Fp)` 的形式。表示两个增量会合合之后变成多大的增量。

   **注意：**如果增量的囤积函数不满足交换律，那么请将先来的增量放到第二个参数位置上，后来的增量放到第一个参数位置上。
   
   **注意：** `__defaultValue` 需要满足：`__op(__defaultValue, __defaultValue)==__defaultValue` 。`__defaultIncrement` 需要满足：`__com(__defaultIncrement,__defaultIncrement)==__defaultIncrement`。此外，`__map(__defaultIncrement,__defaultValue,(1))==__defaultValue`。由于 `_Tp,_Fp` 类型不一定支持相等运算符，所以 `_check` 函数默认处于注释掉的状态。如果取消注释，则会在建树时进行检查。

#### 2.建立线段树

1. 数据类型

   构造参数 `_Iterator __first` ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到线段树里。
   


#### 3.重置

1. 数据类型

   输入参数 `int __n` ，表示线段树要处理的区间大小。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   调用本函数会将线段树大小改变，整个区间的值重置为 `m_defaultValue` ，并将之前的合并信息重置。

#### 4.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间维护的区间头。

   输入参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到线段树里。
   
   线段树会把区间长度凑成二的幂，延伸的区域会被 `m_defaultValue` 覆盖。

#### 5.单点赋值

1. 数据类型

   输入参数 `int __i​` ，表示单点赋值的下标。

   输入参数 `_Tp __val​` ，表示赋的值。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 6.单点增值

1. 数据类型

   输入参数 `int __i​` ，表示单点增值的下标。

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 7.区间增值

1. 数据类型

   输入参数 `int __left​` ，表示增值的区间起始下标。

   输入参数 `int __right` ，表示增值的区间结尾下标。（闭区间）

   输入参数 `_Fp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 8.单点查询

1. 数据类型

   输入参数 `int __i` ，表示查询的下标。

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）


#### 9.区间查询

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 10.查询全部

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 11.查询第 $k$ 个元素

1. 数据类型

   输入参数 `_Tp __k​` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   仅当线段树的元素类型 `_Tp` 为数字，且区间操作函数为加法的时候，本方法才有意义。

   顺次 `k​` 表示第 `k+1` 小，顺次 `0` 表示查询最小的元素。
   
   本函数没有进行参数检查，所以请自己确保 `__k` 合法。（位于`[0, queryAll())`）

### 三、模板示例

```c++
#include "DS/LazyZkwTree.h"
#include "IO/FastIO.h"

int main() {
    //带懒惰标记的线段树可以实现线段树的所有统计功能
    //重复功能不再展示，主要展示构造方法和一些特有的功能

    //先给出一个长度为 10 的数组
    int A[10] = {11, 5, 9, 12, 8, 4, 6, 15, 7, 7};
    for (int i = 0; i < 10; i++)
        cout << A[i] << (i == 9 ? '\n' : ' ');

    //默认无参构造就是日常用的最多的求和树
    OY::LazyZkwTree T(A, A + 10);
    cout << "sum(A[3~6])     =" << T.query(3, 6) << endl;
    //对区间 [4,5] 赋予 10 的增量变化
    T.add(4, 5, 10);
    cout << "sum(A[3~6])     =" << T.query(3, 6) << endl;
    //查询排名第 54 的元素是谁
    cout << "A.kth(54)       =" << T.kth(54) << endl;
    //查询排名第 55 的元素是谁
    cout << "A.kth(55)       =" << T.kth(55) << endl;

    //增值函数、囤积函数可以和区间操作函数完全不同
    //比如，统计用的是最大值函数，修改用的是加法
    auto getmax = [](int x, int y) { return x > y ? x : y; };
    auto map = [](int x, int y) { return x + y; };
    auto com = [](int x, int y) { return x + y; };
    OY::LazyZkwTree T_max_add(A, A + 10, getmax, map, com);
    cout << "max(A[3~6])     =" << T_max_add.query(3, 6) << endl;
    //对区间 [4,5] 赋予 10 的增量变化
    T_max_add.add(4, 5, 10);
    cout << "max(A[3~6])     =" << T_max_add.query(3, 6) << endl;

    // _Fp 和 _Tp 的类别也可以完全不同
    //比如，维护一个整数序列，对其进行乘法、加法的修改，则可以把乘法加法的增量抽象为一个运算结点
    struct opNode {
        int mul = 1, add = 0;
    };
    auto op = [](int x, int y) { return x + y; };
    auto map2 = [](opNode x, int y) { return y * x.mul + x.add; };
    auto com2 = [](opNode x, opNode y) { return opNode{y.mul * x.mul, y.add * x.mul + x.add}; };
    OY::LazyZkwTree T2(A, A + 10, op, map2, com2);
    for (int i = 0; i < 10; i++) cout << T2.query(i) << (i == 9 ? '\n' : ' ');
    T2.add(2, 5, {1, 5});
    for (int i = 0; i < 10; i++) cout << T2.query(i) << (i == 9 ? '\n' : ' ');
    T2.add(4, 6, {2, 0});
    for (int i = 0; i < 10; i++) cout << T2.query(i) << (i == 9 ? '\n' : ' ');
    T2.add(3, 7, {1, 10});
    for (int i = 0; i < 10; i++) cout << T2.query(i) << (i == 9 ? '\n' : ' ');
    cout << "sum(A[~])       =" << T2.queryAll() << endl;
}
```

```
#输出如下
11 5 9 12 8 4 6 15 7 7
sum(A[3~6])     =30
sum(A[3~6])     =50
A.kth(54)       =4
A.kth(55)       =5
max(A[3~6])     =12
max(A[3~6])     =18
11 5 9 12 8 4 6 15 7 7
11 5 14 17 13 9 6 15 7 7
11 5 14 17 26 18 12 15 7 7
11 5 14 27 36 28 22 25 7 7
sum(A[~])       =172


```

