### 一、模板类别

​	数据结构：位集

### 二、模板功能

#### 1.建立位集

1. 数据类型

   模板参数 `int _Depth` ，表示一块的大小是 `1<<_Depth` 个 `unsigned long long` 。比如在默认参数 `_Depth=6` 的情况下，一块的大小是 `64` 个 `unsigned long long ` ，即 `4096` 个比特。

   构造参数 `int __n` ，表示位集的大小为 `__n`。

2. 时间复杂度

   $O(\frac n \omega )$ ，其中 `ω` 表示 `unsigned long long` 所包含的比特数量—— `64` 。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有长度无法改变、无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   本数据结构没有实现按位左移和按位右移的功能。

   本数据结构是由一个一个的块组成的，而块的大小是被模板参数 `_Depth` 在编译器就确定的。为方便起见，以下操作分析时间复杂度时，默认位集大小为 `1<<_depth*2` 的数量级，即块数与块内字节数在同一数量级。

#### 2.重置

1. 数据类型

   输入参数 `int __n` ，表示位集的大小为 `__n`。

2. 时间复杂度

   同上。



####  3.全部置为 1

1. 数据类型

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。

#### 4.将某一位置为 1

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 位置置为 `1` 。

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   大部分情况下，时间复杂度为 $O(1)$ ；除非数据故意卡。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 5.将某一区间置为 1

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  6.全部置为 0

1. 数据类型

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。

#### 7.将某一位置为 0

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 位置置为 `0` 。

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   大部分情况下，时间复杂度为 $O(1)$ ；除非数据故意卡。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 8.将某一区间置为 0

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  9.全部翻转

1. 数据类型

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。

#### 10.将某一位置翻转

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 翻转。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.将某一区间翻转

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 12.查询第一个 1 的位置

1. 数据类型

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   如果使用找到第一个一，然后不断找后一个一的方式遍历所有一的位置，那么总时间复杂度不会超过 $O(n)$ 。

#### 13.查询前一个 1 的位置

1. 数据类型

   输入参数 `int __i` ，表示当前下标。

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   当位集中下标 `__i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 14.查询后一个 1 的位置

1. 数据类型

   输入参数 `int __i` ，表示当前下标。

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   当位集中下标 `__i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 15.查询最后一个 1 的位置

1. 数据类型

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   如果使用找到最后一个一，然后不断找前一个一的方式遍历所有一的位置，那么总时间复杂度不会超过 $O(n)$ 。但是会比找到第一个一，然后不断找后一个一的方式要慢。

#### 16.查询 1 的总数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 17.查询区间中 1 的总数

1. 数据类型

   输入参数 `int __left` ，表示要查询的区间的起始下标。

   输入参数 `int __right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\sqrt \frac n \omega)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询某下标

1. 数据类型

   输入参数 `int __i` ，表示要查询的下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 19.查询是否全部为 1

1. 数据类型

2. 时间复杂度

   $O(1)$ 。
   

#### 20.查询是否有 1

1. 数据类型

2. 时间复杂度

   $O(1)$。


#### 21.按位与

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(n)$ 。
   

#### 22.按位或

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(n)$ 。

#### 23.按位异或

1. 数据类型

   两个同类型、同大小的位集参与运算。

2. 时间复杂度

   $O(n)$ 。

#### 三、模板示例

```c++
#include "DS/Bitset.h"
#include "IO/FastIO.h"

int main(){
    OY::Bitset<6>B(10000);
    //将区间置为 1
    B.set(1000,3000);
    cout<<"B[1000~2000]="<<B.count(1000,2000)<<endl;
    //将区间置为 0
    B.reset(500,1400);
    cout<<"B[1000~2000]="<<B.count(1000,2000)<<endl;
    //将整个位集翻转
    B.flip();
    cout<<"B[1000~2000]="<<B.count(1000,2000)<<endl;
    
    for(int i=1395;i<1405;i++)
        cout<<"index "<<i<<":"<<B.at(i)<<endl;

    //全部置为 0
    B.reset();

    B.set(16);
    B.set(980);
    B.set(357);
    B.set(2);
    for(int i=B.first();i>=0;i=B.next(i))
        cout<<i<<' ';
    cout<<endl;
    for(int i=B.last();i>=0;i=B.prev(i))
        cout<<i<<' ';
    cout<<endl;

    //再来一个一样大的位集，进行位运算
    OY::Bitset<6>B2(10000);
    B2.set(16);
    B2.set(500);
    B2.set(166);
    B2.set(980);

    //按位与
    auto S1=B&B2;
    for(int i=S1.first();i>=0;i=S1.next(i))
        cout<<i<<' ';
    cout<<endl;

    //按位或
    auto S2=B|B2;
    for(int i=S2.first();i>=0;i=S2.next(i))
        cout<<i<<' ';
    cout<<endl;

    //按位异或
    auto S3=B^B2;
    for(int i=S3.first();i>=0;i=S3.next(i))
        cout<<i<<' ';
    cout<<endl;
}
```

```
#输出如下
B[1000~2000]=1001
B[1000~2000]=600
B[1000~2000]=401
index 1395:1
index 1396:1
index 1397:1
index 1398:1
index 1399:1
index 1400:1
index 1401:0
index 1402:0
index 1403:0
index 1404:0
2 16 357 980 
980 357 16 2 
16 980 
2 16 166 357 500 980 
2 166 357 500 

```

