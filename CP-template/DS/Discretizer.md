### 一、模板类别

​	数据结构：离散化数组

### 二、模板功能

#### 1.建立离散化数组

1. 数据类型

   模板参数 `typename _Tp`​ ，表示离散化的元素类型。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本数据结构继承自 `std::vector` ，所以可以使用 `std::vector` 的成员方法。比如，为了减少数组的扩容复制次数，可以使用 `reserve` 方法预留空间。
   
   以下只介绍特有的方法。


#### 2.输入元素

1. 数据类型

   输入参数 `_Tp __item` ，表示要参与离散化的元素。

2. 时间复杂度

   $O(1)$ 。
   

#### 3.输入元素数组

1. 数据类型

   参数 `std::vector<_Tp> __items` ，表示要参与离散化的元素所组成的数组。

2. 时间复杂度

   $O(n)$  。

#### 4.输入元素二维数组

1. 数据类型

   参数 `std::vector<std::vector<_Tp>> __items` ，表示要参与离散化的元素所组成的二维数组。

2. 时间复杂度

   $O(n)$  。

#### 5.准备

1. 数据类型

2. 时间复杂度

   $O(n\log (n))$ 。
   
3. 备注

   本方法会对数组内的元素排序、去重，之后数组就不再接受新元素。


#### 6.获取排名

1. 数据类型

   输入参数 `_Tp __item`，表示要查询离散化编号的元素

2. 时间复杂度

   $O(log(n))$ 。
   
3. 备注

   如果该元素不在集合中，则返回若该元素在集合中，将会处于的名次。

#### 7.二分下界

1. 数据类型

   输入参数 `_Tp __item`，表示要查询的元素

2. 时间复杂度

   $O(log(n))$ 。
   
3. 备注

   等同于调用 `std::lower_bound` 。

#### 8.二分上界

1. 数据类型

   输入参数 `_Tp __item`，表示要查询的元素

2. 时间复杂度

   $O(log(n))$ 。

3. 备注

   等同于调用 `std::upper_bound` 。

### 三、模板示例

```c++
#include "DS/Discretizer.h"
#include "IO/FastIO.h"

int main() {
    OY::Discretizer D;
    D << 11 << 22 << 33;
    std::vector<int> arr{15, 25, 35};
    std::vector<std::vector<int>> arr_2d{{100, 200}, {400, 300}, {15, 25}};
    D << arr << arr_2d;
    //准备后不会再接受数据
    D.prepare();
    for (int i = 0; i < D.size(); i++) {
        cout << "D[" << i << "]=\t" << D[i] << endl;
    }
    cout << "rank of " << 24 << "=" << D.rank(24) << endl;
    cout << "rank of " << 25 << "=" << D.rank(25) << endl;
    cout << "rank of " << 26 << "=" << D.rank(26) << endl;
}
```

```
#输出如下
D[0]=	11
D[1]=	15
D[2]=	22
D[3]=	25
D[4]=	33
D[5]=	35
D[6]=	100
D[7]=	200
D[8]=	300
D[9]=	400
rank of 24=3
rank of 25=3
rank of 26=4

```

