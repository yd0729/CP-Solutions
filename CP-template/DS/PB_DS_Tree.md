### 一、模板类别

​	数据结构：平衡二叉树中的红黑树（借助 `pb_ds` 库实现）

### 二、模板功能

​	平衡树的实现方法有差别，但是在使用的时候完全不需要知道实现的细节，只需要知道对外的接口。

#### 1.建立平衡树

1. 数据类型

   模板参数 `_typename _Tp` ，表示树中的键类型。

   模板参数 `_typename _Fp` ，表示树中的值类型。在 `set` 和 `multiset` 里不需要这个参数，将其设置为 `bool` 类型。

   模板参数 `typename _Compare` ，表示排序函数的类，默认为 `_Tp` 的小于号比较类。

   模板参数 `_Tag`，表示树的类型:

   1. `_Tag=PB_DS_TreeSetTag` 表示树模拟 `std::set` ；
   2. `_Tag=PB_DS_TreeMultisetetTag` 表示树模拟 `std::multiset` ；
   3. `_Tag=PB_DS_TreeMapTag` 表示树模拟 `std::map` ；

   构造参数 `_Compare  __comp` ，表示具体的排序函数，默认为`_Compare` 类的默认实例。

2. 时间复杂度

   $O(1)$ 。

#### 2.清空

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 3.插入键/键值对

1. 数据类型：

   参数 `_Tp __key`​ ，表示要插入的键。

   参数 `_Fp __value` ，表示要插入的值。本参数仅在 `map` 里用到。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   在 `set` 里如果键重复则不会插入；在 `map` 里如果键重复则不会插入。

#### 4.更新键值对

1. 数据类型：

   参数 `_Tp __key`​ ，表示要更新的键。

   参数 `_Fp __value` ，表示要更新的值。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数只适用于 `map` ；如果键不存在则会插入新的键值对。

#### 5.删除键

1. 数据类型：

   参数 `_Tp __key`​ ，表示要删除的键。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数适用于所有类型；如果允许键重复则只删除一个而非全部。

#### 6.删除键

1. 数据类型：

   参数 `_Tp __key`​ ，表示要删除的键。

   参数 `int __count` ，表示要删除的数量。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数只适用于 ``multiset` ；如果不够删除则不执行。

#### 7.获取排名

1. 数据类型：

   参数 `_Tp __key`​ ，表示要获取排名的键。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数的排名以 `0` 为基准；实际等同于树中小于该键值的元素数量。

#### 8.查找第 k 个元素

1. 数据类型：

   参数 `int __k` ，表示要查询的顺次。

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数的排名以 `0` 为基准。

#### 9.查找元素

1. 数据类型：

   参数 `_Tp __key` ，表示要查询的键。

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 10.二分下界

1. 数据类型：

   参数 `_Tp __key` ，表示要查询的键。

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 11.二分上界

1. 数据类型：

   参数 `_Tp __key` ，表示要查询的键。

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 12.二分下界的前驱

1. 数据类型：

   参数 `_Tp __key` ，表示要查询的键。

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   如果没找到，返回 `nullptr` 。

#### 13.查询树的元素数量

1. 数据类型：

2. 时间复杂度

   $O(1)$ 。

3. 备注

   查询树中元素数量，同元素可以计多次。

#### 14.查询树是否为空

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 15.返回 end 迭代器

1. 数据类型

   返回类型 `PB_DS_Tree::iterator` ，表示元素所在位置。

2. 时间复杂度

   $O(1)$ 。

#### 16.查询某元素数量

1. 数据类型

   参数 `_Tp __key` ，表示要查询的元素。

2. 时间复杂度

   $O(\log n)$ 。


### 三、模板示例

```c++
#include "DS/PB_DS_Tree.h"
#include "IO/FastIO.h"

int main() {
    //本数据结构与替罪羊树包装几乎完全一样
    //区别在于，很多查找函数返回的不是裸指针，而是迭代器，所以判断查找结果失败用的不是 nullptr 而是 end()
    OY::PB_DS_TreeContainer::Set<std::string> set;
    set.insert("apple");
    set.insert("cat");
    set.insert("banana");
    auto p = set.find("dog");
    cout << "find iterator->" << (p == set.end() ? "end()" : "something") << endl;
}

```

```
#输出如下
find iterator->end()

```

