### 一、模板类别

​	数据结构：使用 `FHQTreap` 树实现的动态数组。

### 二、模板功能

#### 1.构造动态数组

1. 数据类型

   模板参数 `_typename _Tp` ，表示元素类型。

2. 时间复杂度

   $O(1)$ 。
   
3. 备注

   本数据结构没有正式名字，我将其命名为动态数组。

   顾名思义，动态数组是数组的拓展，所以接口和功能和 `std::vector` 极为相像。动态数组的优势在于可以以对数时间复杂度在任意位置完成插入、删除的功能；而且动态数组提供了区间翻转的功能。

#### 2.构造动态数组

1. 数据类型

   构造参数 `_Iterator __first` ，表示区间开始位置。

   构造参数 `_Iterator __last` ，表示区间结尾位置。（开区间）

   其余同上。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法以区间来进行填充数组，速度较一个一个地插入要快。

#### 3.设置内存池大小

1. 数据类型

   输入参数 `int __count`，表示程序运行最多用到的结点数量。

2. 时间复杂度

   $O(n)$

#### 4.清空

1. 数据类型

2. 时间复杂度

   $O(1)$ 。


#### 5.插入元素

1. 数据类型：

   参数 `int __pos` ，表示要插入的下标位置。

   参数 `_Tp __key`​ ，表示要插入的值。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n]`）

#### 6.更新元素

1. 数据类型：

   参数 `int __pos` ，表示要更新的下标位置。

   参数 `_Tp __key`​ ，表示要更新为的值。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 7.删除元素

1. 数据类型：

   参数 `int __pos` ，表示要删除的下标位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 8.删除区间

1. 数据类型：

   参数 `int __left` ，表示要删除的区间的起始下标。

   参数 `int __right` ，表示要删除的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 9.从区间构建

1. 数据类型：

   输入参数 `_Iterator __first` ，表示区间开始位置。

   输入参数 `_Iterator __last` ，表示区间结尾位置。（开区间）

2. 时间复杂度

   $O(n)$ 。

#### 10.区间翻转

1. 数据类型：

   参数 `int __left` ，表示要翻转的区间的起始下标。

   参数 `int __right` ，表示要翻转的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 11.在开头插入元素

1. 数据类型：

   参数 `_Tp __key` ，表示要插入的值。

2. 时间复杂度

   $O(\log n)$ 。


#### 12.删除开头元素

1. 数据类型：

2. 时间复杂度

   $O(\log n)$ 。


#### 13.在结尾插入元素

1. 数据类型：

   参数 `_Tp __key` ，表示要插入的值。

2. 时间复杂度

   $O(\log n)$ 。

#### 14.删除结尾元素

1. 数据类型：

2. 时间复杂度

   $O(\log n)$ 。

#### 15.查找某下标的元素所在结点

1. 数据类型：

   参数 `int __pos` ，表示要查找的下标位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法返回的是该下标位置元素所在的结点的指针。对这个指针的 `key` 属性进行修改就可以实现对数组的修改。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 16.查找某下标的元素

1. 数据类型：

   参数 `int __pos` ，表示要查找的下标位置。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法返回的是该下标位置元素的引用。对它进行修改就可以实现对数组的修改。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 17.查找开头元素

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。


#### 18.查找结尾元素

1. 数据类型：

2. 时间复杂度

   $O(\log n)$ 。


#### 19.查询数组大小

1. 数据类型

2. 时间复杂度

   $O(1)$ 。


#### 20.查询数组是否为空

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 21.获取子数组

1. 数据类型

   参数 `int __left` ，表示要获取的子区间的起始下标。

   参数 `int __right` ，表示要获取的子区间的结尾下标。（闭区间）

   返回类型 `FHQTreapArray<_Tp>` ，即与原数组类型相同。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法是将原数组的一部分切了出来，所以调用之后，原数组会将相应区间切掉。

#### 22.合并其他数组

1. 数据类型

   输入参数 `FHQTreapArray<_Tp> &__other` ，即与原数组类型相同的另一数组。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法使用后，另一数组会接在本数组之后；另一数组变为空数组。

#### 23.转为 std::vector

1. 数据类型

2. 时间复杂度

   $O(n)$ 。

### 三、模板示例

```c++
#include "DS/FHQTreapArray.h"
#include "IO/FastIO.h"

int main(){
    //动态数组的大部分接口都和 std::vector 一致，所以只展示不同的
    int A[10] = {11, 5, 9, 12, 8, 4, 6, 15, 7, 7};
    for (int i = 0; i < 10; i++)
        cout << A[i] << (i == 9 ? '\n' : ' ');

    //如果不填模板参数，默认为 int 类型
    OY::FHQTreapArray arr;
    arr.assign(A,A+10);
    for(int a:arr.to_vector())cout<<a<<' ';
    cout<<endl;

    arr.insert(0,100);
    cout<<"insert 100: ";
    for(int a:arr.to_vector())cout<<a<<' ';
    cout<<endl;

    arr.erase(3);
    cout<<"erase index 3: ";
    for(int a:arr.to_vector())cout<<a<<' ';
    cout<<endl;

    arr.reverse(0,arr.size()-1);
    cout<<"reverse all: ";
    for(int a:arr.to_vector())cout<<a<<' ';
    cout<<endl;

    arr.erase(2,4);
    cout<<"erase index 2~4: ";
    for(int a:arr.to_vector())cout<<a<<' ';
    cout<<endl;

    auto sub1=arr.subArray(4,6);
    auto sub2=arr.subArray(0,3);
    sub1.join(sub2);
    cout<<"sub[4~6]+sub[0~3]: ";
    for(int a:sub1.to_vector())cout<<a<<' ';
    cout<<endl;

    for(int i=0;i<sub1.size();i++)sub1[i]=i;
    cout<<"assign value by index: ";
    for(int a:sub1.to_vector())cout<<a<<' ';
    cout<<endl;
}
```

```
#输出如下
11 5 9 12 8 4 6 15 7 7
11 5 9 12 8 4 6 15 7 7 
insert 100: 100 11 5 9 12 8 4 6 15 7 7 
erase index 3: 100 11 5 12 8 4 6 15 7 7 
reverse all: 7 7 15 6 4 8 12 5 11 100 
erase index 2~4: 7 7 8 12 5 11 100 
sub[4~6]+sub[0~3]: 5 11 100 7 7 8 12 
assign value by index: 0 1 2 3 4 5 6 

```

