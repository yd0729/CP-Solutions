### 一、模板类别

​	数学：大步小步算法。

### 二、模板功能

   本模板分为普通版和扩展版，普通版用于解决底数和模数之间互质的情况，而扩展版可以进一步解决二者不互质的情况。
   在保证互质的情况下，首先考虑使用普通版，因为其速度最快。

#### 1.构造

1. 数据类型

   模板参数 `typename _ModType` ，可以为 `uint32_t` 或者 `uint64_t` ，表示模数的类型。

   模板参数 `uint32_t_HashP` ，表示算法中用到的哈希表的取模模数。

   模板参数 `uint32_t_HashN` ，表示算法中用到的哈希表的表大小。至少要达到查询模数的平方根大小。

   构造参数 `_ModType __a` ，表示底数。

   构造参数 `_ModType __r` ，表示对模数求余的结果。

   构造参数 `_ModType __P` ，表示模数。

   构造参数 `_ModType __coef` ，表示左侧系数，默认值为 `1` 。本函数只在普通版中出现。

2. 时间复杂度

   $O(\sqrt n)$ 。

3. 备注

   本模板用于计算离散对数。既然是“对数”，就涉及到幂运算，设 `__coef * __a ^ x ≡ __r mod __P` ，已知 `__a,__r,__P,__coef` ，本模板可以求出 `x` 。

   本模板的时间空间占用均为模数的平方根级别，所以模数 `__P` 虽然可以是 `64` 位整数，但是最好控制在 `10^14` 以内。

   **注意：** 有的离散对数可能没有答案，这种情况下返回 `-1` 。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/BSGS.h"

int main() {
    auto x = OY::BSGS32<100007, 50000>(20, 4, 99, 5);
    if (~x) {
        cout << "5 * 20 ^ " << x << " % 99 = 4\n";
    } else {
        cout << "no answer\n";
    }

    auto y = OY::BSGS_ex32<100007, 50000>(20, 8, 98);
    if (~y) {
        cout << "20 ^ " << y << " % 98 = 8\n";
    } else {
        cout << "no answer\n";
    }
}
```

```
#输出如下
5 * 20 ^ 3 % 99 = 4
20 ^ 2 % 98 = 8

```

