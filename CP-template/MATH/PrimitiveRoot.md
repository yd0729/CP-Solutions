### 一、模板类别

​	数学：原根。

### 二、模板功能

​	本模板需要进行分解质因数，而分解质因数有两种不同的策略：一种是在一定的值域范围内进行筛法预处理；一种是没有筛法预处理，通过 `Pollard-Pho` 方法进行概率分解。前者在值域范围内运行速度较快（约为后者 `1.5` 倍），后者没有预处理耗时且适用的值域范围更大（可至 `10^18` ）。

#### 1.判断某数是不是某模数的原根

1. 数据类型

   输入参数 `_ModType a` ，表示要判断的数。

   输入参数 `_ModType phi` ，表示要查询的模数的欧拉函数值。

   输入参数 `std::vector<_ModType> &sub` ，表示要查询的模数的欧拉函数值所生成的子数组。

   输入参数 `Barrett<_ModType> &brt` ，表示要查询的模数的巴雷特约减模板。


2. 时间复杂度

    取决于模数质因数的数量，一般可以认为是常数较大的 $O(\log n)$ 。（此处的 `n` 指欧拉函数值，当然作为数量级，相当于模数的数量级）。

    **注意：** 一个模数的原根可以有很多个。

#### 2.查询最小原根

1. 数据类型

   输入参数 `_ModType P` ，表示要查询的模数。要求为正数。

2. 时间复杂度

   $O(n^{0.25} \cdot \log n)$ 。

3. 备注

   本函数的时间复杂度为基于概率的时间复杂度。据称一个模数的最小原根的数量级在 `n^0.25` 级别，而对每个数字判断原根是否为原根的复杂度为对数级别。

   当一个模数不存在原根时，返回 `0` 。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/PrimitiveRoot.h"

int main() {
    int proot_of_26 = OY::PrimitiveRoot32_Sieve<10000000>::queryMin(26);
    cout << proot_of_26 << " ^ " << OY::Pollard_Rho::EulerPhi<uint32_t>(26) << " mod 26 == 1\n";

    proot_of_26 = OY::PrimitiveRoot32_PollardPho::queryMin(26);
    cout << proot_of_26 << " ^ " << OY::Pollard_Rho::EulerPhi<uint32_t>(26) << " mod 26 == 1\n";
}
```

```
#输出如下
7 ^ 12 mod 26 == 1
7 ^ 12 mod 26 == 1

```

