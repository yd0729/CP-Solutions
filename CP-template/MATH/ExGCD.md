### 一、模板类别

​	数学：扩展欧几里得算法。

### 二、模板功能

#### 1.求解最大公约数

1. 数据类型

   输入参数 `int64_t a` ，表示第一个数。

   输入参数 `int64_t b` ，表示第二个数。

   返回类型 `_exGCD_ans` ，其 `g` 属性表示求出的最大公约数，`k1` 属性和 `k2` 属性表示配平数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本模板基于欧几里得算法求解最大公约数，并给出 `a` 和 `b` 的配平数，使得 `a*k1+b*k2=g` 。这样的配平数可以存在无数多组，但只返回其中一组。
   特别的，当 `a=b=0` 时，返回 `g=k1=k2=0` 。

#### 2.求解配平式

1. 数据类型

   输入参数 `int64_t a` ，表示第一个数。

   输入参数 `int64_t b` ，表示第二个数。

   输入参数 `int64_t c` ，表示等于的值。

   返回类型 `_exGCD_ans` ，其 `g` 属性表示求出的最大公约数， `res` 属性表示配平式的值，`k1` 属性表示 `a` 的配平数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本模板基于欧几里得算法计算配平数，使得 `a*k1+b*k2=c` 。这样的配平数可以存在无数多组，返回的一组是令 `k1>=0` 且 `k1` 最小的一组，也就是 `k1` 为最小的非负整数的一组。本算法只偏重计算合适的 `k1` ，所以 `k2` 很有可能超出一定的数值范围，所以没有返回 `k2` 。

   **注意：** 当无法配平时，返回 `res=0` 。所以只需要检查返回的 `res` 属性就可以知道配平成功与否。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/ExGCD.h"

int main() {
    int a=100;
    int b=-85;
    //只找出最大公约数
    auto [g,k1,k2]=OY::exGCD(a,b);
    cout<<"gcd of "<<a<<" and "<<b<<" is: "<<g<<endl;
    cout<<a<<" * "<<k1<<" + "<<b<<" * "<<k2<<" = "<<g<<endl;

    //尝试配平 -20
    int c=-20;
    auto [g2,res,k3]=OY::exGCD(a,b,c);
    if(res==c){
        cout<<"gcd of "<<a<<" and "<<b<<" is: "<<g2<<endl;
        auto k4=(c-k3*a)/b;
        cout<<a<<" * "<<k3<<" + "<<b<<" * "<<k4<<" = "<<res<<endl;
    }
    else{
        cout<<"failed\n";
    }
}
```

```
#输出如下
gcd of 100 and -85 is: 5
100 * 6 + -85 * 7 = 5
gcd of 100 and -85 is: 5
100 * 10 + -85 * 12 = -20

```

