### 一、模板类别

​	数学：乘法逆元（静态取模）。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `typename _ModType` ，可以为 `uint32_t` 或者 `uint64_t` ，表示模数的类型。

   模板参数 `_ModType __P` ，表示模数。
   
   模板参数 `bool __isPrime` ，表示模数是否为质数。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本模板用于以对数时间查询固定模数下的乘法逆元。
   
   与另一模板相比，本模板用于静态取模，也就是模数在编译期已知。本模板运行速度较优。

   本模板的方法均为静态方法，所以可以不构造实例就调用。

#### 2.查询逆元（费马小定理算法）

1. 数据类型

   输入参数 `uint32_t __a` ，表示查询它的乘法逆元。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法需要保证模数为质数。
   
   本方法不进行参数检查，所以请确保输入的参数不是模数的倍数。

#### 3.查询逆元（扩展欧几里得算法）

1. 数据类型

   输入参数 `uint32_t __a` ，表示查询它的乘法逆元。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本方法不需要保证模数为质数，只要输入参数和模数互质就可以求出逆元。

   本方法略慢于费马小定理算法。

#### 4.查询逆元

1. 数据类型

   输入参数 `uint32_t __a` ，表示查询它的乘法逆元。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   根据模数是否为质数，灵活确定算法。

#### 5.查询区间上若干个数的逆元

1. 数据类型

   输入参数 `_Iterator __first` ，表示查询区间的首位置。

   输入参数 `_Iterator __last` ，表示查询区间的尾位置。（开区间）

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法需要保证区间上的所有数和模数都是互质的。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/StaticModularInverse.h"

int main() {
    OY::StaticModularInverse32<1000000007, true> solver;
    auto inv = solver.query(87654321);
    cout << 87654321 << " * " << inv << " % 1000000007 = " << 87654321ll * inv % 1000000007 << endl;

    //静态方法可以直接用类名调用
    inv = OY::StaticModularInverse32<1000000007, true>::query(87654321);
    cout << 87654321 << " * " << inv << " % 1000000007 = " << 87654321ll * inv % 1000000007 << endl;

    int A[3] = {1000, 2000, 3000};
    auto invs = solver.query(A, A + 3);
    for (int i = 0; i < 3; i++) {
        int a = A[i];
        int inv = invs[i];
        cout << a << " * " << inv << " % 1000000007 = " << uint64_t(a) * inv % 1000000007 << endl;
    }
}
```

```
#输出如下
87654321 * 679671461 % 1000000007 = 1
87654321 * 679671461 % 1000000007 = 1
1000 * 857000006 % 1000000007 = 1
2000 * 428500003 % 1000000007 = 1
3000 * 952333340 % 1000000007 = 1

```

