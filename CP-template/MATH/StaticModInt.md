### 一、模板类别

​	数学：自取模整数（静态模数）

### 二、模板功能

​	很多方法的时间复杂度都是 $O(1)$ ，但是加/减法、乘法、除法/取模同为 $O(1)$ ，时间效率却可以差很多倍，所以在时间复杂度内会额外写明是否经过复杂运算。

#### 1.构造

1. 数据类型

   模板参数 `typename _ModType` ，可以为 `uint32_t` 或者 `uint64_t` ，表示模数的类型。

   模板参数 `_ModType _P ` ，表示当前类的模数。

   模板参数 `bool _IsPrime ` ，表示当前类的模数是否认证为质数。默认为 `false` 。

   模板参数 `std::enable_if_t<_P<1ull < 63> * = nullptr` ，表示限制模数在 `[2, 2^63)` 范围内。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   该类型虽然封装为结构体，但是类内只含有一个无符号整数成员变量，内存只占用 `4/8` 个字节。

   该类型可以当作带有自动取模功能的整数，模数在编译期被模板参数所确定。

   无参情况下，值会被初始化为 `0` 。

   可以显式地转换为 `int​` ，`unsigned int` ，`long long` ，`unsigned long long` ，`double` ，`long double` 等类型。

   支持 `+` ，`-`，`×` ，`÷` ， `+=` ，`-=`，`×=` ，`÷=` ，`++` ，`--` ，`+`（正号），`-`（负号） ，`==` ，`!=` ，`＜` ，`＞` ，`≤` ，`≥` 等运算符。

   支持输入输出流操作。

   **注意：**本模板和另一个自取模整数模板的区别是，本模板的模数在编译期是已知的，所以在运行期不可以改变。在计算效率上，本模板比较快，所以如果模数在编译期就已知，最好使用本模板。

#### 2.构造

1. 数据类型

   构造参数 `_Tp __val` ，其中 `_Tp` 为有符号的数类型，`__val` 可正可负。

   其余同上。

2. 时间复杂度

   $O(1)$ ，有一次取模运算。

3. 备注

   在`__val` 为负时，按商向下取余计算。比如 `-59%10`，按照 `-59/10=-6,-59-10*6=1` 来计算，所以值为 `1` 。

   其余同上。

#### 3.构造

1. 数据类型

   构造参数 `_Tp __val` ，其中 `_Tp` 为无符号的数类型。

   其余同上。

2. 时间复杂度

   $O(1)$ ，有一次取模运算。

3. 备注

   同上。

#### 4.直接构造

1. 数据类型

   输入参数 `_ModType __val` ，表示直接用 `__val` 作为初始值。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   本方法为类的静态方法，所以不需要实例也可以使用；

   本方法要求保证 `__val` 在 `[0, mod())` 范围内，使用本方法进行构造不会经过取模，所以速度更快。

#### 5.查询模数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本方法为类的静态方法，所以不需要实例也可以使用；

#### 6.查询值

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在正确情况下，本方法返回的值只可能在 `[0,mod())` 范围内。

#### 7.求快速幂

1. 数据类型

   输入参数 `uint64_t __n` ，表示幂的指数大小。

2. 时间复杂度

   $O(\log P)$ ，包含对数级别次数的乘法运算。

#### 8.求逆元

1. 数据类型

2. 时间复杂度

   $O(\log P)$ 。如果使用费马小定理算法，包含对数级别次数的乘法；如果使用扩展欧几里得算法，包含对数级别次数的乘法和对数级别次数的除法。

3. 备注

   如果模数被认证为质数，那么会采用费马小定理算法；如果模数没有被认证为质数，那么会采用扩展欧几里得算法。一般来说，扩展欧几里得算法的运算次数较少，但是由于除法运算非常慢，所以综合效率不如费马小定理算法。

#### 9.各种运算符

1. 数据类型

2. 时间复杂度

   对于 `++`，`--`，`+=`，`-=`，`+`（正号），`-`（负号），`==`，`!=`，`<`，`>`，`＜`，`＞`，`+`，`-`，时间复杂度为 $O(1)$ ，无复杂运算。

   对于 `×=` ， `×` ，时间复杂度为 $O(1)$ ，包含三次乘法运算。

   对于 `÷=` ， `÷` ，时间复杂度为 $O(\log n)$ ，包含的运算和求逆元相同。

3. 备注

   运算符的效果非常显然，就是令值参与运算，然后取模即可。不一一阐述。

#### 10.强制类型转换

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/StaticModInt.h"

int main() {
    //可以给类型起个名字，方便识读
    using mint_97 = OY::StaticModInt32<97, true>;

    mint_97 a = 280, b = 20;
    cout << "(280 + 20) mod 97 = " << a + b << endl;
    cout << "(280 - 20) mod 97 = " << a - b << endl;
    cout << "(280 * 20) mod 97 = " << a * b << endl;
    cout << "(280 / 20) mod 97 = " << a / b << endl;

    //求 95 的阶乘的模
    mint_97 A[95];
    //采用 raw 方法进行构造，可以避免无意义的取模
    for (int i = 0; i < 95; i++) A[i] = mint_97::raw(i + 1);
    //另开一个数组，从前往后累乘
    mint_97 B[95];
    B[0] = 1;
    for (int i = 1; i < 95; i++) B[i] = B[i - 1] * A[i];
    //模为 1，验证费马小定理
    cout << "product from 1 to 95 is: " << B[94] << endl;

    //现在问一个问题，怎么求从 81 乘到 95 的乘积是多少？
    //当然我们可以从头开始算，但是最好是别重算
    //如果把 B 数组堪称一个类似“前缀和”数组的“前缀积”数组，就可以通过差分来算
    cout << "product from 81 to 95 is: " << (B[94] / B[79]) << endl;
    //或者写成
    cout << "product from 81 to 95 is: " << (B[94] * B[79].inv()) << endl;
    //显然，“逆元”可以理解为“倒数”

    //如果我们还想要对另一个模数进行运算，我们可以另起一个类型
    //尽管 233 确实是质数，但是我们不给它认证成质数也无伤大雅
    using mint_233 = OY::StaticModInt64<233, false>;
    //求 2 的 8 次方
    cout << "pow(2,8) is: " << mint_233(2).pow(8) << endl;
    //求 2 的一亿次方
    cout << "pow(2,100000000) is: " << mint_233(2).pow(100000000) << endl;
}
```

```
#输出如下
(280 + 20) mod 97 = 9
(280 - 20) mod 97 = 66
(280 * 20) mod 97 = 71
(280 / 20) mod 97 = 14
product from 1 to 95 is: 1
product from 81 to 95 is: 25
product from 81 to 95 is: 25
pow(2,8) is: 23
pow(2,100000000) is: 102

```

