# LC

## 2258. 逃离火灾

正向 BFS ，计算每个位置着火的时间，得到 fire ．

反向 Dijkstra ，反推最迟到达时间，得到 late ．

- Time: $\mathcal{O}(mn)$
- Space: $\mathcal{O}(mn)$

## 937. 重新排列日志文件

自定义排序．

这道题必须用 `stable_sort` ，因为要求数字日志的相对顺序不变．

尽量用 C 的字符串操作可以避免拷贝，提高性能，节省内存．

用 C++ 20 的 `string_view` 和 `<=>` 也可以．

## 591. 标签验证器 ⭐️

递归下降子程序还是比较通用的方法，虽然用在这道题上有点杀鸡用牛刀，从代码量上看其实和栈的方法也没差多少．

如果理解了递归下降子程序，应该也可以顺利写出栈的版本．

栈的版本可以进一步优化，但是我选择 cv ．

## 420. 强密码检查器 ⭐️

[【Sheep】420. 强密码检验器（贪心）](https://leetcode.cn/problems/strong-password-checker/solution/si-lu-qing-xi-c-0ms-by-13261896688/)

考虑三种修改方式在三个方面的影响．

## 4. 寻找两个正序数组的中位数 ⭐️

[官方题解](https://leetcode.cn/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/)

### 二分查找

1. 在两个有序的数组上求中位数可以转化为求第 K 小的元素问题．
2. 求第 K 小的元素，只要累计删掉 K - 1 个数就行．
3. 但要注意不能删多了，所以每次在每个数组上将第 K / 2 小的数作为的分界点．

### 划分数组

1. 求中位数，可以转化在两个数组上确定一个划分．
2. 由中位数的性质，如果确定了一个数组中的划分位置，另一个数组中的位置也就相应确定了．
3. 所以只需要在一个数组上移动，找到正确的划分位置．
4. 而这个问题仍然是具有单调性质的，所以可以使用二分来确定划分的位置．
5. 这种方法的时间复杂度最小．

## 3. 无重复字符的最长子串

哈希记录每个字符上次出现的位置．

## 2. 两数相加

用链表模拟加法．

## 1. 两数之和

哈希表 ，一边遍历一边更新哈希表就可以，因为总是可以在遇到第 2 个数的时候找到．
